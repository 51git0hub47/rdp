name: Public Minecraft Server

on:
  workflow_dispatch:
    inputs:
      restore_world:
        description: 'Restore previous world backup'
        required: false
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'

jobs:
  public-minecraft:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Configure Core RDP Settings (for management)
        run: |
          # Enable RDP for server management
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          Restart-Service -Name TermService -Force
          # Create admin user
          $password = -join ((65..90) + (97..122) + (48..57) | Get-Random -Count 12 | % {[char]$_})
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          try { Remove-LocalUser -Name "Admin" -ErrorAction SilentlyContinue } catch {}
          New-LocalUser -Name "Admin" -Password $securePass -AccountNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "Admin"
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member "Admin"
          
          echo "ADMIN_PASSWORD=$password" >> $env:GITHUB_ENV

      - name: Install Tailscale (for RDP access)
        run: |
          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-1.82.0-amd64.msi"
          $installerPath = "$env:TEMP\tailscale.msi"
          Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath
          Start-Process msiexec.exe -ArgumentList "/i", "`"$installerPath`"", "/quiet", "/norestart" -Wait
          Remove-Item $installerPath -Force

      - name: Connect to Tailscale
        run: |
          & "$env:ProgramFiles\Tailscale\tailscale.exe" up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=mc-public-$env:GITHUB_RUN_ID
          $tsIP = $null
          $retries = 0
          while (-not $tsIP -and $retries -lt 15) {
              try {
                  $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
                  if ($tsIP) { $tsIP = $tsIP.Trim() }
              } catch { Start-Sleep -Seconds 3 }
              $retries++
          }
          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV

      - name: Download and Setup Minecraft Server
        run: |
          # Create server directory
          $serverDir = "C:\MinecraftServer"
          New-Item -Path $serverDir -ItemType Directory -Force
          
          # Updated Minecraft server download URLs
          $mcUrls = @(
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.95.1.zip",
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.93.4.zip",
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.92.3.zip",
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.90.2.zip"
          )
          
          $zipPath = "$serverDir\bedrock-server.zip"
          $downloaded = $false
          
          foreach ($url in $mcUrls) {
              try {
                  Write-Host "Attempting to download Minecraft Bedrock Server from: $url"
                  
                  # Use different download methods
                  try {
                      # Try with TLS 1.2
                      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                      Invoke-WebRequest -Uri $url -OutFile $zipPath -UserAgent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" -TimeoutSec 300
                      $downloaded = $true
                      Write-Host "âœ… Successfully downloaded from: $url"
                      break
                  } catch {
                      Write-Host "âŒ Failed with Invoke-WebRequest: $($_.Exception.Message)"
                      
                      # Try with WebClient as fallback
                      try {
                          Write-Host "ğŸ”„ Trying alternative download method..."
                          $webClient = New-Object System.Net.WebClient
                          $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
                          $webClient.DownloadFile($url, $zipPath)
                          $downloaded = $true
                          Write-Host "âœ… Successfully downloaded using WebClient from: $url"
                          break
                      } catch {
                          Write-Host "âŒ WebClient also failed: $($_.Exception.Message)"
                      }
                  }
              } catch {
                  Write-Host "âŒ Failed to download from $url : $($_.Exception.Message)"
                  continue
              }
          }
          
          if (-not $downloaded) {
              Write-Error "âŒ Failed to download Minecraft server from all sources"
              Write-Host "ğŸ” Network connectivity test:"
              try {
                  Test-NetConnection -ComputerName "minecraft.net" -Port 443
                  Test-NetConnection -ComputerName "8.8.8.8" -Port 443
              } catch {
                  Write-Host "Network test failed: $($_.Exception.Message)"
              }
              exit 1
          }
          
          Write-Host "ğŸ“¦ Extracting server files..."
          try {
              Expand-Archive -Path $zipPath -DestinationPath $serverDir -Force
              Remove-Item $zipPath -ErrorAction SilentlyContinue
          } catch {
              Write-Error "âŒ Failed to extract server files: $($_.Exception.Message)"
              exit 1
          }
          
          # Accept EULA
          Set-Content -Path "$serverDir\eula.txt" -Value "eula=true"
          
          Write-Host "âœ… Minecraft server downloaded, extracted, and EULA accepted"

      - name: Setup Backup System
        run: |
          # Create backup directory
          New-Item -Path "C:\WorldBackups" -ItemType Directory -Force
          Write-Host "âœ… Backup system initialized"

      - name: Restore Previous World (if requested)
        run: |
          if ("${{ github.event.inputs.restore_world }}" -eq "true") {
              Write-Host "ğŸ”„ Attempting to restore previous world..."
              
              try {
                  # Get list of artifacts from this repo
                  $artifactUrl = "https://api.github.com/repos/${{ github.repository }}/actions/artifacts"
                  $headers = @{ 
                      Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                      Accept = "application/vnd.github+json"
                  }
                  
                  $artifacts = Invoke-RestMethod -Uri $artifactUrl -Headers $headers
                  $latestBackup = $artifacts.artifacts | Where-Object { 
                      $_.name -like "minecraft-world-backups-*" -and $_.expired -eq $false 
                  } | Sort-Object created_at -Descending | Select-Object -First 1
                  
                  if ($latestBackup) {
                      Write-Host "ğŸ“¦ Found backup artifact: $($latestBackup.name)"
                      Write-Host "ğŸ“… Created: $($latestBackup.created_at)"
                      
                      # Download the artifact
                      $downloadUrl = $latestBackup.archive_download_url
                      $backupZip = "$env:TEMP\world_restore.zip"
                      
                      Write-Host "â¬‡ï¸ Downloading backup..."
                      Invoke-WebRequest -Uri $downloadUrl -Headers $headers -OutFile $backupZip
                      
                      # Extract to temporary location first
                      $tempExtract = "$env:TEMP\extracted_backup"
                      New-Item -Path $tempExtract -ItemType Directory -Force
                      Expand-Archive -Path $backupZip -DestinationPath $tempExtract -Force
                      
                      # Find the actual world backup files and restore them
                      $backupFiles = Get-ChildItem -Path $tempExtract -Filter "*.zip" -Recurse
                      if ($backupFiles.Count -gt 0) {
                          $latestWorldBackup = $backupFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                          Write-Host "ğŸŒ Restoring world from: $($latestWorldBackup.Name)"
                          
                          # Create worlds directory and restore
                          $worldsDir = "C:\MinecraftServer\worlds"
                          New-Item -Path $worldsDir -ItemType Directory -Force
                          Expand-Archive -Path $latestWorldBackup.FullName -DestinationPath $worldsDir -Force
                          
                          Write-Host "âœ… World successfully restored!"
                          echo "WORLD_RESTORED=true" >> $env:GITHUB_ENV
                      } else {
                          Write-Host "âš ï¸ No world backup files found in artifact"
                          echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
                      }
                      
                      # Cleanup
                      Remove-Item $backupZip -Force -ErrorAction SilentlyContinue
                      Remove-Item $tempExtract -Recurse -Force -ErrorAction SilentlyContinue
                      
                  } else {
                      Write-Host "âš ï¸ No previous world backup found, starting with fresh world"
                      echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
                  }
              } catch {
                  Write-Host "âŒ Error restoring world: $($_.Exception.Message)"
                  Write-Host "Starting with fresh world instead"
                  echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
              }
          } else {
              Write-Host "ğŸ†• Starting with fresh world (restore not requested)"
              echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
          }

      - name: Install and Setup ngrok
        run: |
          # Download ngrok
          $ngrokUrl = "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip"
          $ngrokPath = "$env:TEMP\ngrok.zip"
          
          Write-Host "Downloading ngrok..."
          Invoke-WebRequest -Uri $ngrokUrl -OutFile $ngrokPath
          Expand-Archive -Path $ngrokPath -DestinationPath "C:\ngrok" -Force
          Remove-Item $ngrokPath
          
          # Add ngrok to PATH
          $env:PATH += ";C:\ngrok"
          [Environment]::SetEnvironmentVariable("PATH", $env:PATH, [EnvironmentVariableTarget]::Machine)
          
          Write-Host "âœ… ngrok installed"

      - name: Start Minecraft Server
        run: |
          $serverDir = "C:\MinecraftServer"
          Write-Host "Starting Minecraft server..."
          
          if ($env:WORLD_RESTORED -eq "true") {
              Write-Host "ğŸ”„ Starting server with restored world..."
          } else {
              Write-Host "ğŸ†• Starting server with fresh world..."
          }
          
          # Start server in background
          $serverProcess = Start-Process -FilePath "$serverDir\bedrock_server.exe" -WorkingDirectory $serverDir -PassThru -WindowStyle Hidden
          echo "SERVER_PID=$($serverProcess.Id)" >> $env:GITHUB_ENV
          
          # Wait for server to fully start and generate world
          Write-Host "â³ Waiting for server startup and world generation..."
          Start-Sleep -Seconds 30
          
          if (Get-Process -Id $serverProcess.Id -ErrorAction SilentlyContinue) {
              Write-Host "âœ… Minecraft server started!"
          } else {
              Write-Error "Failed to start Minecraft server"
              exit 1
          }

      - name: Expose Server with ngrok
        run: |
          Write-Host "Starting ngrok tunnel..."
          
          # Start ngrok in background
          $ngrokProcess = Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "udp", "19132" -PassThru -WindowStyle Hidden
          echo "NGROK_PID=$($ngrokProcess.Id)" >> $env:GITHUB_ENV
          
          # Wait for ngrok to start
          Write-Host "â³ Waiting for ngrok to establish tunnel..."
          Start-Sleep -Seconds 15
          
          # Get the public URL from ngrok API with retries
          $publicUrl = $null
          $retries = 0
          
          while (-not $publicUrl -and $retries -lt 10) {
              try {
                  Write-Host "ğŸ” Attempt $($retries + 1): Checking ngrok API..."
                  $ngrokInfo = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -TimeoutSec 10
                  
                  if ($ngrokInfo.tunnels -and $ngrokInfo.tunnels.Count -gt 0) {
                      $publicUrl = $ngrokInfo.tunnels[0].public_url
                      $publicUrl = $publicUrl -replace "udp://", ""
                      echo "PUBLIC_URL=$publicUrl" >> $env:GITHUB_ENV
                      Write-Host "âœ… ngrok tunnel established: $publicUrl"
                      break
                  } else {
                      Write-Host "âš ï¸ No tunnels found in API response"
                  }
              } catch {
                  Write-Host "âš ï¸ API check failed: $($_.Exception.Message)"
              }
              
              $retries++
              if ($retries -lt 10) {
                  Write-Host "â³ Waiting 5 seconds before retry..."
                  Start-Sleep -Seconds 5
              }
          }
          
          if (-not $publicUrl) {
              Write-Host "âŒ Could not get ngrok URL after 10 attempts"
              Write-Host "ğŸ”§ Manual check required - ngrok process may still be working"
              echo "PUBLIC_URL=Check ngrok dashboard at http://localhost:4040" >> $env:GITHUB_ENV
              
              # Don't fail the workflow, continue with monitoring
              Write-Host "âš ï¸ Continuing with server monitoring despite ngrok URL issue"
          }

      - name: Initial World Backup
        run: |
          # Wait longer for world to be properly generated
          Write-Host "â³ Waiting for world generation and stabilization (2 minutes)..."
          Start-Sleep -Seconds 120
          
          # Create initial backup using improved method
          $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          $backupName = "initial_backup_$timestamp"
          $backupPath = "C:\WorldBackups\$backupName.zip"
          
          Write-Host "ğŸ’¾ Creating initial world backup..."
          
          # Check multiple possible world locations
          $possibleWorldPaths = @(
              "C:\MinecraftServer\worlds",
              "C:\MinecraftServer\world",
              "C:\MinecraftServer\Bedrock level"
          )
          
          $worldPath = $null
          foreach ($path in $possibleWorldPaths) {
              if (Test-Path $path) {
                  $worldPath = $path
                  Write-Host "ğŸ“ Found world data at: $worldPath"
                  break
              }
          }
          
          if ($worldPath -and (Get-ChildItem $worldPath -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
              try {
                  # Use robocopy for better file handling with retry
                  $tempBackupDir = "$env:TEMP\minecraft_initial_$timestamp"
                  New-Item -Path $tempBackupDir -ItemType Directory -Force
                  
                  # Copy files with retry logic
                  $copySuccess = $false
                  for ($i = 1; $i -le 3; $i++) {
                      try {
                          Write-Host "ğŸ“‚ Copy attempt $i of 3..."
                          robocopy "$worldPath" "$tempBackupDir" /E /R:2 /W:1 /NP
                          $copySuccess = $true
                          break
                      } catch {
                          Write-Host "âš ï¸ Copy attempt $i failed: $($_.Exception.Message)"
                          Start-Sleep -Seconds 5
                      }
                  }
                  
                  if ($copySuccess -and (Get-ChildItem $tempBackupDir -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
                      Compress-Archive -Path "$tempBackupDir\*" -DestinationPath $backupPath -Force
                      Remove-Item $tempBackupDir -Recurse -Force -ErrorAction SilentlyContinue
                      Write-Host "âœ… Initial backup created successfully: $backupName"
                  } else {
                      Write-Host "âš ï¸ No files copied, skipping initial backup"
                  }
              } catch {
                  Write-Host "âš ï¸ Initial backup failed: $($_.Exception.Message)"
                  # Don't fail the entire workflow for backup issues
                  Write-Host "ğŸ”„ Server will continue running without initial backup"
              }
          } else {
              Write-Host "âš ï¸ No world data found yet, will backup on first scheduled interval"
          }

      - name: Display Server Information
        run: |
          Write-Host ""
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host "                ğŸ® PUBLIC MINECRAFT SERVER WITH BACKUPS ğŸ®          "
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host ""
          
          if ($env:PUBLIC_URL -and $env:PUBLIC_URL -ne "Check ngrok dashboard at http://localhost:4040") {
              Write-Host "ğŸŒ PUBLIC SERVER ADDRESS: $env:PUBLIC_URL"
          } else {
              Write-Host "ğŸŒ PUBLIC SERVER ADDRESS: Check http://localhost:4040 for ngrok URL"
              Write-Host "   (ngrok is running but API didn't respond - check manually)"
          }
          
          Write-Host "ğŸ¯ Game Mode: Default (from server defaults)"
          Write-Host "ğŸ‘¥ Max Players: Default (from server defaults)"
          Write-Host "ğŸ”“ Authentication: Default (from server defaults)"
          if ($env:WORLD_RESTORED -eq "true") {
              Write-Host "ğŸ”„ World Status: RESTORED from previous session"
          } else {
              Write-Host "ğŸ†• World Status: FRESH world"
          }
          Write-Host ""
          Write-Host "ğŸ’¾ BACKUP SCHEDULE:"
          Write-Host "   â€¢ Initial: After world generation"
          Write-Host "   â€¢ Periodic: Every 30 minutes"
          Write-Host "   â€¢ Final: When server stops"
          Write-Host "   â€¢ Emergency: If unexpected shutdown"
          Write-Host ""
          Write-Host "ğŸ“± How to connect:"
          Write-Host "1. Open Minecraft Bedrock Edition"
          Write-Host "2. Go to Play â†’ Servers â†’ Add Server"
          Write-Host "3. Enter the server address above"
          Write-Host "4. Connect and enjoy!"
          Write-Host ""
          Write-Host "ğŸ–¥ï¸  RDP Access (for server management):"
          if ($env:TAILSCALE_IP) {
              Write-Host "   Install Tailscale and connect to: $env:TAILSCALE_IP"
              Write-Host "   Username: Admin"
              Write-Host "   Password: $env:ADMIN_PASSWORD"
          } else {
              Write-Host "   âš ï¸ RDP not available (Tailscale not configured)"
              Write-Host "   To enable RDP: Add TAILSCALE_AUTH_KEY to repository secrets"
          }
          Write-Host ""
          Write-Host "ğŸ”§ Manual ngrok check: http://localhost:4040"
          Write-Host ""
          Write-Host "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          Write-Host ""

      - name: Monitor Server with Auto-Backup
        run: |
          $startTime = Get-Date
          $lastBackup = Get-Date
          $counter = 0
          $backupCounter = 1  # We attempted initial backup
          
          Write-Host "ğŸŸ¢ PUBLIC Minecraft Server is LIVE with AUTO-BACKUP!"
          if ($env:PUBLIC_URL -and $env:PUBLIC_URL -ne "Check ngrok dashboard at http://localhost:4040") {
              Write-Host "ğŸŒ Connect: $env:PUBLIC_URL"
          } else {
              Write-Host "ğŸŒ Connect: Check http://localhost:4040 for ngrok URL"
          }
          Write-Host "ğŸ’¾ Next backup in 30 minutes"
          Write-Host "âš ï¸  Server will run for up to 6 hours"
          Write-Host ""
          
          function Create-WorldBackup {
              param($backupType = "scheduled")
              
              $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
              $backupName = "${backupType}_backup_$timestamp"
              $backupPath = "C:\WorldBackups\$backupName.zip"
              
              Write-Host "ğŸ’¾ Creating $backupType backup: $backupName"
              
              # Check multiple possible world locations
              $possibleWorldPaths = @(
                  "C:\MinecraftServer\worlds",
                  "C:\MinecraftServer\world",
                  "C:\MinecraftServer\Bedrock level"
              )
              
              $worldPath = $null
              foreach ($path in $possibleWorldPaths) {
                  if (Test-Path $path -and (Get-ChildItem $path -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
                      $worldPath = $path
                      break
                  }
              }
              
              if ($worldPath) {
                  try {
                      # Create backup with retry logic
                      $tempBackupDir = "$env:TEMP\minecraft_backup_$timestamp"
                      New-Item -Path $tempBackupDir -ItemType Directory -Force
                      
                      # Use robocopy for file copying
                      $robocopyResult = robocopy "$worldPath" "$tempBackupDir" /E /R:1 /W:1 /NP /NFL /NDL
                      
                      if (Test-Path $tempBackupDir -and (Get-ChildItem $tempBackupDir -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
                          Compress-Archive -Path "$tempBackupDir\*" -DestinationPath $backupPath -Force
                          Remove-Item $tempBackupDir -Recurse -Force -ErrorAction SilentlyContinue
                          Write-Host "âœ… Backup created successfully"
                          return $true
                      } else {
                          Write-Host "âš ï¸ No files to backup"
                          return $false
                      }
                  } catch {
                      Write-Host "âŒ Backup failed: $($_.Exception.Message)"
                      # Cleanup temp directory
                      Remove-Item $tempBackupDir -Recurse -Force -ErrorAction SilentlyContinue
                      return $false
                  }
              } else {
                  Write-Host "âš ï¸ No world data found to backup"
                  return $false
              }
          }
          
          try {
              while ($true) {
                  $counter++
                  $elapsed = (Get-Date) - $startTime
                  $elapsedStr = "{0:hh\:mm\:ss}" -f $elapsed
                  
                  # Check if 30 minutes passed since last backup
                  $timeSinceBackup = (Get-Date) - $lastBackup
                  if ($timeSinceBackup.TotalMinutes -ge 30) {
                      $backupCounter++
                      Write-Host ""
                      Write-Host "â° Time for scheduled backup #$backupCounter"
                      
                      if (Create-WorldBackup -backupType "scheduled") {
                          $lastBackup = Get-Date
                          $nextBackup = $lastBackup.AddMinutes(30)
                          Write-Host "â° Next backup scheduled for: $($nextBackup.ToString('HH:mm:ss'))"
                      }
                      Write-Host ""
                  }
                  
                  # Check server status
                  $serverRunning = Get-Process -Id $env:SERVER_PID -ErrorAction SilentlyContinue
                  $ngrokRunning = Get-Process -Id $env:NGROK_PID -ErrorAction SilentlyContinue
                  
                  if ($serverRunning -and $ngrokRunning) {
                      $nextBackupIn = 30 - $timeSinceBackup.TotalMinutes
                      
                      if ($env:PUBLIC_URL -and $env:PUBLIC_URL -ne "Check ngrok dashboard at http://localhost:4040") {
                          Write-Host "[$elapsedStr] ğŸ® SERVER ONLINE | Connect: $env:PUBLIC_URL | Next backup in: $([math]::Round($nextBackupIn)) min"
                      } else {
                          Write-Host "[$elapsedStr] ğŸ® SERVER ONLINE | URL: http://localhost:4040 | Next backup in: $([math]::Round($nextBackupIn)) min"
                      }
                      
                      # Get connection info if available
                      try {
                          $tunnelInfo = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -ErrorAction SilentlyContinue -TimeoutSec 5
                          if ($tunnelInfo.tunnels -and $tunnelInfo.tunnels.Count -gt 0) {
                              $connections = $tunnelInfo.tunnels[0].metrics.conns.count
                              Write-Host "           ğŸ“Š Active connections: $connections | Backups created: $backupCounter"
                              
                              # Update PUBLIC_URL if we got it now
                              if (-not $env:PUBLIC_URL -or $env:PUBLIC_URL -eq "Check ngrok dashboard at http://localhost:4040") {
                                  $newUrl = $tunnelInfo.tunnels[0].public_url -replace "udp://", ""
                                  if ($newUrl) {
                                      echo "PUBLIC_URL=$newUrl" >> $env:GITHUB_ENV
                                      $env:PUBLIC_URL = $newUrl
                                      Write-Host "           ğŸŒ URL discovered: $newUrl"
                                  }
                              }
                          } else {
                              Write-Host "           ğŸ“Š Tunnel status: OK | Backups created: $backupCounter"
                          }
                      } catch {
                          Write-Host "           ğŸ“Š Tunnel status: OK | Backups created: $backupCounter"
                      }
                  } else {
                      Write-Host ""
                      Write-Host "âŒ Server or tunnel stopped, creating final backup..."
                      Create-WorldBackup -backupType "final"
                      exit 1
                  }
                  
                  Start-Sleep -Seconds 180  # Status update every 3 minutes
              }
          } catch {
              Write-Host ""
              Write-Host "âš ï¸ Server monitoring interrupted: $_"
              Write-Host "ğŸ’¾ Creating emergency backup..."
              Create-WorldBackup -backupType "emergency"
              throw
          } finally {
              Write-Host ""
              Write-Host "ğŸ”´ Public server session ended"
              Write-Host "ğŸ“Š Total runtime: $elapsedStr"
              Write-Host "ğŸ’¾ Total backups created: $backupCounter"
              Write-Host ""
              
              # Cleanup processes
              try {
                  Stop-Process -Id $env:SERVER_PID -Force -ErrorAction SilentlyContinue
                  Stop-Process -Id $env:NGROK_PID -Force -ErrorAction SilentlyContinue
              } catch {}
          }

      - name: Upload World Backups as Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: minecraft-world-backups-${{ github.run_id }}
          path: C:\WorldBackups\*.zip
          retention-days: 30
