name: Public Minecraft Server

on:
  workflow_dispatch:
    inputs:
      restore_world:
        description: 'Restore previous world backup'
        required: false
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'
      enable_rdp:
        description: 'Enable RDP access'
        required: false
        default: 'true'
        type: choice
        options:
        - 'true'
        - 'false'
      tunnel_service:
        description: 'Choose tunnel service'
        required: false
        default: 'cloudflared'
        type: choice
        options:
        - 'cloudflared'
        - 'ngrok'
        - 'serveo'

jobs:
  public-minecraft:
    runs-on: windows-latest
    timeout-minutes: 360

    steps:
      - name: Configure Core RDP Settings (if enabled)
        if: github.event.inputs.enable_rdp == 'true'
        run: |
          # Enable RDP for server management
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          Restart-Service -Name TermService -Force
          # Create admin user
          $password = -join ((65..90) + (97..122) + (48..57) | Get-Random -Count 12 | % {[char]$_})
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          try { Remove-LocalUser -Name "Admin" -ErrorAction SilentlyContinue } catch {}
          New-LocalUser -Name "Admin" -Password $securePass -AccountNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "Admin"
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member "Admin"
          
          echo "ADMIN_PASSWORD=$password" >> $env:GITHUB_ENV
          echo "RDP_ENABLED=true" >> $env:GITHUB_ENV

      - name: Install Tailscale (if RDP enabled)
        if: github.event.inputs.enable_rdp == 'true' && secrets.TAILSCALE_AUTH_KEY != ''
        run: |
          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-1.82.0-amd64.msi"
          $installerPath = "$env:TEMP\tailscale.msi"
          Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath
          Start-Process msiexec.exe -ArgumentList "/i", "`"$installerPath`"", "/quiet", "/norestart" -Wait
          Remove-Item $installerPath -Force

      - name: Connect to Tailscale (if RDP enabled)
        if: github.event.inputs.enable_rdp == 'true' && secrets.TAILSCALE_AUTH_KEY != ''
        run: |
          & "$env:ProgramFiles\Tailscale\tailscale.exe" up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=mc-public-$env:GITHUB_RUN_ID
          $tsIP = $null
          $retries = 0
          while (-not $tsIP -and $retries -lt 15) {
              try {
                  $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
                  if ($tsIP) { $tsIP = $tsIP.Trim() }
              } catch { Start-Sleep -Seconds 3 }
              $retries++
          }
          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV

      - name: Download and Setup Minecraft Server
        run: |
          # Create server directory
          $serverDir = "C:\MinecraftServer"
          New-Item -Path $serverDir -ItemType Directory -Force
          
          # Updated Minecraft server download URLs
          $mcUrls = @(
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.95.1.zip",
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.93.4.zip",
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.92.3.zip",
              "https://minecraft.net/bedrockdedicatedserver/bin-win/bedrock-server-1.21.90.2.zip"
          )
          
          $zipPath = "$serverDir\bedrock-server.zip"
          $downloaded = $false
          
          foreach ($url in $mcUrls) {
              try {
                  Write-Host "Attempting to download Minecraft Bedrock Server from: $url"
                  
                  # Use different download methods
                  try {
                      # Try with TLS 1.2
                      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
                      Invoke-WebRequest -Uri $url -OutFile $zipPath -UserAgent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" -TimeoutSec 300
                      $downloaded = $true
                      Write-Host "✅ Successfully downloaded from: $url"
                      break
                  } catch {
                      Write-Host "❌ Failed with Invoke-WebRequest: $($_.Exception.Message)"
                      
                      # Try with WebClient as fallback
                      try {
                          Write-Host "🔄 Trying alternative download method..."
                          $webClient = New-Object System.Net.WebClient
                          $webClient.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
                          $webClient.DownloadFile($url, $zipPath)
                          $downloaded = $true
                          Write-Host "✅ Successfully downloaded using WebClient from: $url"
                          break
                      } catch {
                          Write-Host "❌ WebClient also failed: $($_.Exception.Message)"
                      }
                  }
              } catch {
                  Write-Host "❌ Failed to download from $url : $($_.Exception.Message)"
                  continue
              }
          }
          
          if (-not $downloaded) {
              Write-Error "❌ Failed to download Minecraft server from all sources"
              Write-Host "🔍 Network connectivity test:"
              try {
                  Test-NetConnection -ComputerName "minecraft.net" -Port 443
                  Test-NetConnection -ComputerName "8.8.8.8" -Port 443
              } catch {
                  Write-Host "Network test failed: $($_.Exception.Message)"
              }
              exit 1
          }
          
          Write-Host "📦 Extracting server files..."
          try {
              Expand-Archive -Path $zipPath -DestinationPath $serverDir -Force
              Remove-Item $zipPath -ErrorAction SilentlyContinue
          } catch {
              Write-Error "❌ Failed to extract server files: $($_.Exception.Message)"
              exit 1
          }
          
          # Accept EULA
          Set-Content -Path "$serverDir\eula.txt" -Value "eula=true"
          
          Write-Host "✅ Minecraft server downloaded, extracted, and EULA accepted"

      - name: Setup Backup System
        run: |
          # Create backup directory
          New-Item -Path "C:\WorldBackups" -ItemType Directory -Force
          Write-Host "✅ Backup system initialized"

      - name: Restore Previous World (if requested)
        run: |
          if ("${{ github.event.inputs.restore_world }}" -eq "true") {
              Write-Host "🔄 Attempting to restore previous world..."
              
              try {
                  # Get list of artifacts from this repo
                  $artifactUrl = "https://api.github.com/repos/${{ github.repository }}/actions/artifacts"
                  $headers = @{ 
                      Authorization = "Bearer ${{ secrets.GITHUB_TOKEN }}"
                      Accept = "application/vnd.github+json"
                  }
                  
                  $artifacts = Invoke-RestMethod -Uri $artifactUrl -Headers $headers
                  $latestBackup = $artifacts.artifacts | Where-Object { 
                      $_.name -like "minecraft-world-backups-*" -and $_.expired -eq $false 
                  } | Sort-Object created_at -Descending | Select-Object -First 1
                  
                  if ($latestBackup) {
                      Write-Host "📦 Found backup artifact: $($latestBackup.name)"
                      Write-Host "📅 Created: $($latestBackup.created_at)"
                      
                      # Download the artifact
                      $downloadUrl = $latestBackup.archive_download_url
                      $backupZip = "$env:TEMP\world_restore.zip"
                      
                      Write-Host "⬇️ Downloading backup..."
                      Invoke-WebRequest -Uri $downloadUrl -Headers $headers -OutFile $backupZip
                      
                      # Extract to temporary location first
                      $tempExtract = "$env:TEMP\extracted_backup"
                      New-Item -Path $tempExtract -ItemType Directory -Force
                      Expand-Archive -Path $backupZip -DestinationPath $tempExtract -Force
                      
                      # Find the actual world backup files and restore them
                      $backupFiles = Get-ChildItem -Path $tempExtract -Filter "*.zip" -Recurse
                      if ($backupFiles.Count -gt 0) {
                          $latestWorldBackup = $backupFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                          Write-Host "🌍 Restoring world from: $($latestWorldBackup.Name)"
                          
                          # Create worlds directory and restore
                          $worldsDir = "C:\MinecraftServer\worlds"
                          New-Item -Path $worldsDir -ItemType Directory -Force
                          Expand-Archive -Path $latestWorldBackup.FullName -DestinationPath $worldsDir -Force
                          
                          Write-Host "✅ World successfully restored!"
                          echo "WORLD_RESTORED=true" >> $env:GITHUB_ENV
                      } else {
                          Write-Host "⚠️ No world backup files found in artifact"
                          echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
                      }
                      
                      # Cleanup
                      Remove-Item $backupZip -Force -ErrorAction SilentlyContinue
                      Remove-Item $tempExtract -Recurse -Force -ErrorAction SilentlyContinue
                      
                  } else {
                      Write-Host "⚠️ No previous world backup found, starting with fresh world"
                      echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
                  }
              } catch {
                  Write-Host "❌ Error restoring world: $($_.Exception.Message)"
                  Write-Host "Starting with fresh world instead"
                  echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
              }
          } else {
              Write-Host "🆕 Starting with fresh world (restore not requested)"
              echo "WORLD_RESTORED=false" >> $env:GITHUB_ENV
          }

      - name: Install Tunnel Service
        run: |
          $tunnelService = "${{ github.event.inputs.tunnel_service }}"
          Write-Host "Installing tunnel service: $tunnelService"
          
          switch ($tunnelService) {
              "cloudflared" {
                  Write-Host "📥 Installing Cloudflare Tunnel..."
                  $cloudflaredUrl = "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe"
                  $cloudflaredPath = "C:\cloudflared\cloudflared.exe"
                  New-Item -Path "C:\cloudflared" -ItemType Directory -Force
                  Invoke-WebRequest -Uri $cloudflaredUrl -OutFile $cloudflaredPath
                  Write-Host "✅ Cloudflare Tunnel installed"
              }
              
              "ngrok" {
                  Write-Host "📥 Installing ngrok..."
                  $ngrokUrl = "https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip"
                  $ngrokPath = "$env:TEMP\ngrok.zip"
                  Invoke-WebRequest -Uri $ngrokUrl -OutFile $ngrokPath
                  Expand-Archive -Path $ngrokPath -DestinationPath "C:\ngrok" -Force
                  Remove-Item $ngrokPath
                  Write-Host "✅ ngrok installed"
              }
              
              "serveo" {
                  Write-Host "📥 Setting up Serveo (SSH-based)..."
                  # Serveo uses SSH, which is built into Windows 10/11
                  # We'll use the built-in SSH client
                  Write-Host "✅ Serveo ready (uses built-in SSH client)"
              }
          }

      - name: Start Minecraft Server
        run: |
          $serverDir = "C:\MinecraftServer"
          Write-Host "Starting Minecraft server..."
          
          if ($env:WORLD_RESTORED -eq "true") {
              Write-Host "🔄 Starting server with restored world..."
          } else {
              Write-Host "🆕 Starting server with fresh world..."
          }
          
          # Start server in background
          $serverProcess = Start-Process -FilePath "$serverDir\bedrock_server.exe" -WorkingDirectory $serverDir -PassThru -WindowStyle Hidden
          echo "SERVER_PID=$($serverProcess.Id)" >> $env:GITHUB_ENV
          
          # Wait for server to fully start and generate world
          Write-Host "⏳ Waiting for server startup and world generation..."
          Start-Sleep -Seconds 30
          
          if (Get-Process -Id $serverProcess.Id -ErrorAction SilentlyContinue) {
              Write-Host "✅ Minecraft server started!"
          } else {
              Write-Error "Failed to start Minecraft server"
              exit 1
          }

      - name: Expose Server with Tunnel
        run: |
          $tunnelService = "${{ github.event.inputs.tunnel_service }}"
          Write-Host "Starting tunnel service: $tunnelService"
          
          switch ($tunnelService) {
              "cloudflared" {
                  Write-Host "🚀 Starting Cloudflare Tunnel..."
                  $tunnelProcess = Start-Process -FilePath "C:\cloudflared\cloudflared.exe" -ArgumentList "tunnel", "--url", "udp://localhost:19132" -PassThru -WindowStyle Hidden -RedirectStandardOutput "C:\tunnel_output.log" -RedirectStandardError "C:\tunnel_error.log"
                  echo "TUNNEL_PID=$($tunnelProcess.Id)" >> $env:GITHUB_ENV
                  echo "TUNNEL_SERVICE=cloudflared" >> $env:GITHUB_ENV
                  
                  # Wait and try to get URL from logs
                  Start-Sleep -Seconds 15
                  $publicUrl = "Check tunnel logs at C:\tunnel_output.log"
                  
                  # Try to extract URL from logs
                  try {
                      $logContent = Get-Content "C:\tunnel_output.log" -ErrorAction SilentlyContinue
                      $urlLine = $logContent | Where-Object { $_ -match "https://.*trycloudflare\.com" }
                      if ($urlLine) {
                          $publicUrl = ($urlLine -split " " | Where-Object { $_ -match "https://.*trycloudflare\.com" })[0]
                          $publicUrl = $publicUrl -replace "https://", ""
                      }
                  } catch {
                      Write-Host "Could not extract URL from logs, check manually"
                  }
                  
                  echo "PUBLIC_URL=$publicUrl" >> $env:GITHUB_ENV
                  Write-Host "✅ Cloudflare tunnel started: $publicUrl"
              }
              
              "ngrok" {
                  Write-Host "🚀 Starting ngrok tunnel..."
                  $tunnelProcess = Start-Process -FilePath "C:\ngrok\ngrok.exe" -ArgumentList "udp", "19132" -PassThru -WindowStyle Hidden
                  echo "TUNNEL_PID=$($tunnelProcess.Id)" >> $env:GITHUB_ENV
                  echo "TUNNEL_SERVICE=ngrok" >> $env:GITHUB_ENV
                  
                  Start-Sleep -Seconds 15
                  
                  # Try multiple methods to get ngrok URL
                  $publicUrl = $null
                  $retries = 0
                  
                  while (-not $publicUrl -and $retries -lt 5) {
                      try {
                          # Method 1: API
                          $ngrokInfo = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -TimeoutSec 10 -ErrorAction SilentlyContinue
                          if ($ngrokInfo.tunnels -and $ngrokInfo.tunnels.Count -gt 0) {
                              $publicUrl = $ngrokInfo.tunnels[0].public_url -replace "udp://", ""
                          }
                          
                          # Method 2: Check if web interface is accessible
                          if (-not $publicUrl) {
                              $webTest = Invoke-WebRequest -Uri "http://localhost:4040" -TimeoutSec 5 -ErrorAction SilentlyContinue
                              if ($webTest.StatusCode -eq 200) {
                                  $publicUrl = "Check ngrok web interface at http://localhost:4040"
                              }
                          }
                      } catch {
                          Write-Host "Attempt $($retries + 1) failed, retrying..."
                      }
                      $retries++
                      Start-Sleep -Seconds 3
                  }
                  
                  if (-not $publicUrl) {
                      $publicUrl = "ngrok tunnel started - check manually"
                  }
                  
                  echo "PUBLIC_URL=$publicUrl" >> $env:GITHUB_ENV
                  Write-Host "✅ ngrok tunnel started: $publicUrl"
              }
         
      - name: Initial World Backup
        run: |
          # Wait longer for world to be properly generated
          Write-Host "⏳ Waiting for world generation and stabilization (2 minutes)..."
          Start-Sleep -Seconds 120
          
          # Create initial backup using improved method
          $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          $backupName = "initial_backup_$timestamp"
          $backupPath = "C:\WorldBackups\$backupName.zip"
          
          Write-Host "💾 Creating initial world backup..."
          
          # Check multiple possible world locations
          $possibleWorldPaths = @(
              "C:\MinecraftServer\worlds",
              "C:\MinecraftServer\world",
              "C:\MinecraftServer\Bedrock level"
          )
          
          $worldPath = $null
          foreach ($path in $possibleWorldPaths) {
              if (Test-Path $path) {
                  $worldPath = $path
                  Write-Host "📁 Found world data at: $worldPath"
                  break
              }
          }
          
          if ($worldPath -and (Get-ChildItem $worldPath -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
              try {
                  # Use robocopy for better file handling with retry
                  $tempBackupDir = "$env:TEMP\minecraft_initial_$timestamp"
                  New-Item -Path $tempBackupDir -ItemType Directory -Force
                  
                  # Copy files with retry logic
                  $copySuccess = $false
                  for ($i = 1; $i -le 3; $i++) {
                      try {
                          Write-Host "📂 Copy attempt $i of 3..."
                          robocopy "$worldPath" "$tempBackupDir" /E /R:2 /W:1 /NP
                          $copySuccess = $true
                          break
                      } catch {
                          Write-Host "⚠️ Copy attempt $i failed: $($_.Exception.Message)"
                          Start-Sleep -Seconds 5
                      }
                  }
                  
                  if ($copySuccess -and (Get-ChildItem $tempBackupDir -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
                      Compress-Archive -Path "$tempBackupDir\*" -DestinationPath $backupPath -Force
                      Remove-Item $tempBackupDir -Recurse -Force -ErrorAction SilentlyContinue
                      Write-Host "✅ Initial backup created successfully: $backupName"
                  } else {
                      Write-Host "⚠️ No files copied, skipping initial backup"
                  }
              } catch {
                  Write-Host "⚠️ Initial backup failed: $($_.Exception.Message)"
                  # Don't fail the entire workflow for backup issues
                  Write-Host "🔄 Server will continue running without initial backup"
              }
          } else {
              Write-Host "⚠️ No world data found yet, will backup on first scheduled interval"
          }

      - name: Display Server Information
        run: |
          Write-Host ""
          Write-Host "═══════════════════════════════════════════════════════════════════"
          Write-Host "                🎮 PUBLIC MINECRAFT SERVER WITH BACKUPS 🎮          "
          Write-Host "═══════════════════════════════════════════════════════════════════"
          Write-Host ""
          
          Write-Host "🌍 PUBLIC SERVER ADDRESS: $env:PUBLIC_URL"
          Write-Host "🔧 Tunnel Service: ${{ github.event.inputs.tunnel_service }}"
          Write-Host "🎯 Game Mode: Default (configure via RDP)"
          Write-Host "👥 Max Players: Default (configure via RDP)"
          Write-Host "🔓 Authentication: Default (configure via RDP)"
          if ($env:WORLD_RESTORED -eq "true") {
              Write-Host "🔄 World Status: RESTORED from previous session"
          } else {
              Write-Host "🆕 World Status: FRESH world"
          }
          Write-Host ""
          Write-Host "💾 BACKUP SCHEDULE:"
          Write-Host "   • Initial: After world generation"
          Write-Host "   • Periodic: Every 30 minutes"
          Write-Host "   • Final: When server stops"
          Write-Host "   • Emergency: If unexpected shutdown"
          Write-Host ""
          Write-Host "📱 How to connect:"
          Write-Host "1. Open Minecraft Bedrock Edition"
          Write-Host "2. Go to Play → Servers → Add Server"
          Write-Host "3. Enter the server address above"
          Write-Host "4. Connect and enjoy!"
          Write-Host ""
          
          if ("${{ github.event.inputs.enable_rdp }}" -eq "true") {
              Write-Host "🖥️  RDP Access (for server configuration):"
              if ($env:TAILSCALE_IP) {
                  Write-Host "   Install Tailscale and connect to: $env:TAILSCALE_IP"
                  Write-Host "   Username: Admin"
                  Write-Host "   Password: $env:ADMIN_PASSWORD"
              } else {
                  Write-Host "   ⚠️ RDP enabled but Tailscale not configured"
                  Write-Host "   To enable RDP: Add TAILSCALE_AUTH_KEY to repository secrets"
              }
          } else {
              Write-Host "🖥️  RDP Access: DISABLED"
          }
          
          Write-Host ""
          Write-Host "🔧 Manual tunnel check:"
          $tunnelService = "${{ github.event.inputs.tunnel_service }}"
          switch ($tunnelService) {
              "cloudflared" { Write-Host "   Check logs: C:\tunnel_output.log" }
              "ngrok" { Write-Host "   Dashboard: http://localhost:4040" }
              "serveo" { Write-Host "   SSH tunnel active - check process output" }
          }
          Write-Host ""
          Write-Host "═══════════════════════════════════════════════════════════════════"
          Write-Host ""

      - name: Monitor Server with Auto-Backup
        run: |
          $startTime = Get-Date
          $lastBackup = Get-Date
          $counter = 0
          $backupCounter = 1  # We attempted initial backup
          
          Write-Host "🟢 PUBLIC Minecraft Server is LIVE with AUTO-BACKUP!"
          Write-Host "🌍 Connect: $env:PUBLIC_URL"
          Write-Host "🔧 Tunnel: ${{ github.event.inputs.tunnel_service }}"
          Write-Host "💾 Next backup in 30 minutes"
          Write-Host "⚠️  Server will run for up to 6 hours"
          Write-Host ""
          
          function Create-WorldBackup {
              param($backupType = "scheduled")
              
              $timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
              $backupName = "${backupType}_backup_$timestamp"
              $backupPath = "C:\WorldBackups\$backupName.zip"
              
              Write-Host "💾 Creating $backupType backup: $backupName"
              
              # Check multiple possible world locations
              $possibleWorldPaths = @(
                  "C:\MinecraftServer\worlds",
                  "C:\MinecraftServer\world",
                  "C:\MinecraftServer\Bedrock level"
              )
              
              $worldPath = $null
              foreach ($path in $possibleWorldPaths) {
                  if (Test-Path $path -and (Get-ChildItem $path -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
                      $worldPath = $path
                      break
                  }
              }
              
              if ($worldPath) {
                  try {
                      # Create backup with retry logic
                      $tempBackupDir = "$env:TEMP\minecraft_backup_$timestamp"
                      New-Item -Path $tempBackupDir -ItemType Directory -Force
                      
                      # Use robocopy for file copying
                      $robocopyResult = robocopy "$worldPath" "$tempBackupDir" /E /R:1 /W:1 /NP /NFL /NDL
                      
                      if (Test-Path $tempBackupDir -and (Get-ChildItem $tempBackupDir -Recurse -ErrorAction SilentlyContinue).Count -gt 0) {
                          Compress-Archive -Path "$tempBackupDir\*" -DestinationPath $backupPath -Force
                          Remove-Item $tempBackupDir -Recurse -Force -ErrorAction SilentlyContinue
                          Write-Host "✅ Backup created successfully"
                          return $true
                      } else {
                          Write-Host "⚠️ No files to backup"
                          return $false
                      }
                  } catch {
                      Write-Host "❌ Backup failed: $($_.Exception.Message)"
                      # Cleanup temp directory
                      Remove-Item $tempBackupDir -Recurse -Force -ErrorAction SilentlyContinue
                      return $false
                  }
              } else {
                  Write-Host "⚠️ No world data found to backup"
                  return $false
              }
          }
          
          function Get-TunnelStatus {
              $tunnelService = "${{ github.event.inputs.tunnel_service }}"
              $status = @{
                  Running = $false
                  URL = "Unknown"
                  Details = ""
              }
              
              try {
                  switch ($tunnelService) {
                      "cloudflared" {
                          $tunnelProcess = Get-Process -Id $env:TUNNEL_PID -ErrorAction SilentlyContinue
                          if ($tunnelProcess) {
                              $status.Running = $true
                              # Try to get URL from logs
                              try {
                                  $logContent = Get-Content "C:\tunnel_output.log" -ErrorAction SilentlyContinue | Select-Object -Last 10
                                  $urlLine = $logContent | Where-Object { $_ -match "https://.*trycloudflare\.com" }
                                  if ($urlLine) {
                                      $url = ($urlLine -split " " | Where-Object { $_ -match "https://.*trycloudflare\.com" })[0]
                                      $status.URL = $url -replace "https://", ""
                                  }
                              } catch {}
                              $status.Details = "Cloudflare tunnel active"
                          }
                      }
                      
                      "ngrok" {
                          $tunnelProcess = Get-Process -Id $env:TUNNEL_PID -ErrorAction SilentlyContinue
                          if ($tunnelProcess) {
                              $status.Running = $true
                              try {
                                  $ngrokInfo = Invoke-RestMethod -Uri "http://localhost:4040/api/tunnels" -TimeoutSec 3 -ErrorAction SilentlyContinue
                                  if ($ngrokInfo.tunnels -and $ngrokInfo.tunnels.Count -gt 0) {
                                      $status.URL = $ngrokInfo.tunnels[0].public_url -replace "udp://", ""
                                      $status.Details = "ngrok API accessible"
                                  } else {
                                      $status.Details = "ngrok running, check localhost:4040"
                                  }
                              } catch {
                                  $status.Details = "ngrok running, API unavailable"
                              }
                          }
                      }
                      
                      "serveo" {
                          $tunnelProcess = Get-Process -Id $env:TUNNEL_PID -ErrorAction SilentlyContinue
                          if ($tunnelProcess) {
                              $status.Running = $true
                              $status.Details = "Serveo SSH tunnel active"
                          }
                      }
                  }
              } catch {
                  $status.Details = "Error checking tunnel status"
              }
              
              return $status
          }
          
          try {
              while ($true) {
                  $counter++
                  $elapsed = (Get-Date) - $startTime
                  $elapsedStr = "{0:hh\:mm\:ss}" -f $elapsed
                  
                  # Check if 30 minutes passed since last backup
                  $timeSinceBackup = (Get-Date) - $lastBackup
                  if ($timeSinceBackup.TotalMinutes -ge 30) {
                      $backupCounter++
                      Write-Host ""
                      Write-Host "⏰ Time for scheduled backup #$backupCounter"
                      
                      if (Create-WorldBackup -backupType "scheduled") {
                          $lastBackup = Get-Date
                          $nextBackup = $lastBackup.AddMinutes(30)
                          Write-Host "⏰ Next backup scheduled for: $($nextBackup.ToString('HH:mm:ss'))"
                      }
                      Write-Host ""
                  }
                  
                  # Check server status
                  $serverRunning = Get-Process -Id $env:SERVER_PID -ErrorAction SilentlyContinue
                  $tunnelStatus = Get-TunnelStatus
                  
                  if ($serverRunning -and $tunnelStatus.Running) {
                      $nextBackupIn = 30 - $timeSinceBackup.TotalMinutes
                      
                      Write-Host "[$elapsedStr] 🎮 SERVER ONLINE | ${{ github.event.inputs.tunnel_service }}: $($tunnelStatus.URL) | Next backup in: $([math]::Round($nextBackupIn)) min"
                      Write-Host "           📊 $($tunnelStatus.Details) | Backups created: $backupCounter"
                  } else {
                      Write-Host ""
                      Write-Host "❌ Server or tunnel stopped, creating final backup..."
                      Create-WorldBackup -backupType "final"
                      exit 1
                  }
                  
                  Start-Sleep -Seconds 180  # Status update every 3 minutes
              }
          } catch {
              Write-Host ""
              Write-Host "⚠️ Server monitoring interrupted: $_"
              Write-Host "💾 Creating emergency backup..."
              Create-WorldBackup -backupType "emergency"
              throw
          } finally {
              Write-Host ""
              Write-Host "🔴 Public server session ended"
              Write-Host "📊 Total runtime: $elapsedStr"
              Write-Host "💾 Total backups created: $backupCounter"
              Write-Host ""
              
              # Cleanup processes
              try {
                  Stop-Process -Id $env:SERVER_PID -Force -ErrorAction SilentlyContinue
                  Stop-Process -Id $env:TUNNEL_PID -Force -ErrorAction SilentlyContinue
                  if ($env:PROXY_PID) {
                      Stop-Process -Id $env:PROXY_PID -Force -ErrorAction SilentlyContinue
                  }
              } catch {}
          }

      - name: Upload World Backups as Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: minecraft-world-backups-${{ github.run_id }}
          path: C:\WorldBackups\*.zip
          retention-days: 30
